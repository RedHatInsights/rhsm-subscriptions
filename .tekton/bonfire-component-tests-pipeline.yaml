apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: bonfire-component-tests
  labels:
    build.appstudio.redhat.com/pipeline: "bonfire"
spec:
  params:
    - name: BONFIRE_REPO
      type: string
      description: URL of the Git repository use for fetching the tasks
      default: 'https://github.com/RedHatInsights/bonfire-tekton'
    - name: BONFIRE_REVISION
      type: string
      description: Git commit revision to use for fetching the tasks
      default: main
    - name: BONFIRE_IMAGE
      type: string
      description: The container Bonfire image to use for the tekton tasks
    - name: SNAPSHOT
      type: string
      description: |
        Spec section of an ApplicationSnapshot resource. Not all fields of the
        resource are required. A minimal example:
          {
            "components": [
              {
                "containerImage": "quay.io/example/repo:latest"
              }
            ]
          }
        Each "containerImage" in the "components" array is validated.
    - name: EPHEMERAL_ENV_PROVIDER_SECRET
      type: string
      default: ephemeral-env-provider
      description: "Secret for connecting to ephemeral env provider cluster"
    - name: APP_INTERFACE_SECRET
      type: string
      default: app-interface
      description: "Secret for connecting to app-interface"
    - name: APP_NAME
      type: string
      description: name of app-sre "application" folder this component lives in
    - name: COMPONENTS
      type: string
      description: space-separated list of components to load
      default: ""
    - name: COMPONENTS_W_RESOURCES
      type: string
      description: component to keep
      default: ""
    - name: AWS_SECRET
      type: string
      default: rh-artifacts-bucket
      description: Secret with connection details to S3
    - name: BONFIRE_COMPONENT_NAME
      type: string
      default: ""
      description: name of the app-sre component name
    - name: COMPONENT_NAME
      type: string
      description: name of app-sre "resourceTemplate" in deploy.yaml for this component
    - name: EXTRA_DEPLOY_ARGS
      type: string
      description: "Extra arguments for the deployment"
      default: ""
    - name: DEPLOY_FRONTENDS
      type: string
      description: "Deploy frontend in the env or not"
      default: true
    - name: DEPLOY_TIMEOUT
      type: string
      description: "Deploy timeout"
      default: "900"
    - name: DEPLOY_OPTIONAL_DEPS_METHOD
      type: string
      description: "Method to deploy optional dependencies - see bonfire docs https://github.com/redhatinsights/bonfire?tab=readme-ov-file#dependency-processing"
      default: "hybrid"
    - name: PROJECT_REPO
      type: string
      description: "Project repository"
      default: "https://github.com/RedHatInsights/rhsm-subscriptions"
    - name: DATAROUTER_CREDENTIALS_NAME
      type: string
      description: Secret name to take the data router credentials from.
      default: "smqe-datarouter-credentials"
    - name: DATAROUTER-METADATA-PATH
      type: string
      default: "datarouter.json"
      description: Path from root for datarouter metadata file.
    - name: datarouter-url
      type: string
      default: "https://datarouter.ccitredhat.com"
      description: Data Router public URL.
    - name: results-pattern
      type: string
      default: "TEST*.xml"
      description: Patter that Data Router follows to upload tests report.
    - name: attachments-dir
      type: string
      default: ""
      description: Directory containing attachments to upload with test results.
  workspaces:
    - name: shared-workspace
      description: A workspace to share data between tasks
  results:
    - name: ARTIFACTS_URL
      description: URL for the test's artifacts
      value: $(finally.teardown.results.ARTIFACTS_URL)
  finally:
    - name: teardown
      params:
        - name: NS
          value: "$(tasks.reserve-namespace.results.NS)"
        - name: NS_REQUESTER
          value: "$(context.pipelineRun.name)"
        - name: ARTIFACTS_KEY
          value: "$(context.pipelineRun.namespace)/$(context.pipelineRun.name)"
        - name: AWS_SECRET
          value: "$(params.AWS_SECRET)"
        - name: BONFIRE_IMAGE
          value: "$(params.BONFIRE_IMAGE)"
      taskRef:
        resolver: git
        params:
          - name: url
            value: "$(params.BONFIRE_REPO)"
          - name: revision
            value: "$(params.BONFIRE_REVISION)"
          - name: pathInRepo
            value: tasks/teardown.yaml
  tasks:
    - name: extract-revision
      params:
        - name: SNAPSHOT
          value: "$(params.SNAPSHOT)"
        - name: COMPONENT_NAME
          value: "$(params.COMPONENT_NAME)"
      taskSpec:
        params:
          - name: SNAPSHOT
            type: string
          - name: COMPONENT_NAME
            type: string
        results:
          - name: GIT_REVISION
            description: Extracted git revision for the component from SNAPSHOT (empty if not found)
        steps:
          - name: extract
            image: quay.io/konflux-ci/appstudio-utils:latest
            script: |
              #!/usr/bin/env bash
              set -euo pipefail
              echo "extract-revision: component='$(params.COMPONENT_NAME)'"
              rev=$(echo '$(params.SNAPSHOT)' | jq -r --arg name '$(params.COMPONENT_NAME)' '.components[] | select(.name==$name) | .source.git.revision // empty')
              if [ -n "$rev" ] && [ "$rev" != "null" ]; then
                echo "extract-revision: found revision='$rev'"
              else
                echo "extract-revision: no revision found in SNAPSHOT for component; leaving result empty"
              fi
              printf "%s" "$rev" > $(results.GIT_REVISION.path)
    - name: update-extra-deploy-args
      params:
        - name: EXTRA_DEPLOY_ARGS
          value: "$(params.EXTRA_DEPLOY_ARGS)"
        - name: COMPONENTS
          value: "$(params.COMPONENTS)"
        - name: GIT_REVISION
          value: "$(tasks.extract-revision.results.GIT_REVISION)"
      runAfter:
        - extract-revision
      taskSpec:
        params:
          - name: EXTRA_DEPLOY_ARGS
            type: string
          - name: COMPONENTS
            type: string
          - name: GIT_REVISION
            type: string
        results:
          - name: UPDATED_EXTRA_DEPLOY_ARGS
            description: Updated EXTRA_DEPLOY_ARGS with template ref if rhsm component is present
        steps:
          - name: update-args
            image: quay.io/konflux-ci/appstudio-utils:latest
            script: |
              #!/usr/bin/env bash
              set -euo pipefail
              COMPONENTS="$(params.COMPONENTS)"
              EXTRA_DEPLOY_ARGS="$(params.EXTRA_DEPLOY_ARGS)"
              GIT_REVISION="$(params.GIT_REVISION)"

              echo "update-extra-deploy-args: COMPONENTS='$COMPONENTS'"
              echo "update-extra-deploy-args: EXTRA_DEPLOY_ARGS='$EXTRA_DEPLOY_ARGS'"
              echo "update-extra-deploy-args: GIT_REVISION='$GIT_REVISION'"

              UPDATED_ARGS="$EXTRA_DEPLOY_ARGS"

              # Check if 'rhsm' is in the components list
              for component in $COMPONENTS; do
                if [ "$component" = "rhsm" ] && [ -n "$GIT_REVISION" ]; then
                  UPDATED_ARGS="$UPDATED_ARGS --set-template-ref rhsm=$GIT_REVISION"
                  break
                fi
              done

              echo "update-extra-deploy-args: final args='$UPDATED_ARGS'"
              printf "%s" "$UPDATED_ARGS" > $(results.UPDATED_EXTRA_DEPLOY_ARGS.path)
    - name: reserve-namespace
      params:
        - name: NS_REQUESTER
          value: "$(context.pipelineRun.name)"
        - name: EPHEMERAL_ENV_PROVIDER_SECRET
          value: "$(params.EPHEMERAL_ENV_PROVIDER_SECRET)"
        - name: BONFIRE_IMAGE
          value: "$(params.BONFIRE_IMAGE)"
      runAfter:
        - extract-revision
      taskRef:
        resolver: git
        params:
          - name: url
            value: "$(params.BONFIRE_REPO)"
          - name: revision
            value: "$(params.BONFIRE_REVISION)"
          - name: pathInRepo
            value: tasks/reserve-namespace.yaml
    - name: deploy-application
      params:
        - name: BONFIRE_IMAGE
          value: "$(params.BONFIRE_IMAGE)"
        - name: SNAPSHOT
          value: "$(params.SNAPSHOT)"
        - name: NS
          value: "$(tasks.reserve-namespace.results.NS)"
        - name: NS_REQUESTER
          value: "$(context.pipelineRun.name)"
        - name: APP_INTERFACE_SECRET
          value: "$(params.APP_INTERFACE_SECRET)"
        - name: APP_NAME
          value: "$(params.APP_NAME)"
        - name: BONFIRE_COMPONENT_NAME
          value: "$(params.BONFIRE_COMPONENT_NAME)"
        - name: COMPONENTS
          value: "$(params.COMPONENTS)"
        - name: COMPONENTS_W_RESOURCES
          value: "$(params.COMPONENTS_W_RESOURCES)"
        - name: EXTRA_DEPLOY_ARGS
          value: "$(tasks.update-extra-deploy-args.results.UPDATED_EXTRA_DEPLOY_ARGS)"
        - name: DEPLOY_FRONTENDS
          value: "$(params.DEPLOY_FRONTENDS)"
        - name: DEPLOY_TIMEOUT
          value: "$(params.DEPLOY_TIMEOUT)"
        - name: OPTIONAL_DEPS_METHOD
          value: "$(params.DEPLOY_OPTIONAL_DEPS_METHOD)"
      runAfter:
        - reserve-namespace
        - update-extra-deploy-args
      taskRef:
        resolver: git
        params:
          - name: url
            value: "$(params.BONFIRE_REPO)"
          - name: revision
            value: "$(params.BONFIRE_REVISION)"
          - name: pathInRepo
            value: tasks/deploy-frontends.yaml
    - name: clone-repository
      params:
        - name: url
          value: "$(params.PROJECT_REPO)"
        - name: revision
          value: "$(tasks.extract-revision.results.GIT_REVISION)"
      taskRef:
        params:
          - name: name
            value: git-clone
          - name: bundle
            value: quay.io/konflux-ci/tekton-catalog/task-git-clone:0.1@sha256:865cdbe6094ff52d9e5dfc40d44ca5cfa6cee4b665aef91306356652fb84d7cc
          - name: kind
            value: task
        resolver: bundles
      workspaces:
        - name: output
          workspace: shared-workspace
      runAfter:
        - deploy-application
    - name: run-tests-task
      params:
        - name: SERVICE
          value: "$(params.COMPONENT_NAME)"
      workspaces:
        - name: output
          workspace: shared-workspace
      runAfter:
        - clone-repository
      taskSpec:
        params:
          - name: SERVICE
            type: string
            description: The service to be tested. By default, it will run all the tests.
        workspaces:
          - name: output
            description: The workspace where the repository was cloned
        steps:
          - name: cluster-login
            image: "$(params.BONFIRE_IMAGE)"
            env:
              - name: OC_LOGIN_TOKEN
                valueFrom:
                  secretKeyRef:
                    name: $(params.EPHEMERAL_ENV_PROVIDER_SECRET)
                    key: token
              - name: OC_LOGIN_SERVER
                valueFrom:
                  secretKeyRef:
                    name: $(params.EPHEMERAL_ENV_PROVIDER_SECRET)
                    key: url
              - name: BONFIRE_BOT
                value: "true"
            script: |
              #!/bin/bash
              set -ex
              echo "Login to cluster for tests"
              login.sh
              # Set current project to the reserved namespace so default namespace matches tests
              if oc get ns "$(tasks.reserve-namespace.results.NS)" >/dev/null 2>&1; then
                oc config set-context --current --namespace="$(tasks.reserve-namespace.results.NS)" || true
              fi
              # Persist kubeconfig for the next step
              oc config view --minify --raw > "$(workspaces.output.path)/kubeconfig"
          - name: tests
            image: registry.access.redhat.com/ubi9/openjdk-21-runtime
            workingDir: $(workspaces.output.path)/source
            env:
              - name: KUBECONFIG
                value: "$(workspaces.output.path)/kubeconfig"
              - name: NS
                value: "$(tasks.reserve-namespace.results.NS)"
              - name: SERVICE
                value: "$(params.SERVICE)"
            script: |
              #!/bin/bash
              ./mvnw clean install --no-transfer-progress -Pcomponent-tests -am -pl ${SERVICE}/ct -Dswatch.component-tests.global.target=openshift -Dlog.disable-color=true -Dlog.level=FINE -Dlog.print-errors-to-std-err=true -Dswatch.component-tests.services.all.log.enabled=true
    - name: send-results-task
      params:
        - name: SERVICE
          value: "$(params.COMPONENT_NAME)"
      workspaces:
        - name: output
          workspace: shared-workspace
      runAfter:
        - run-tests-task
      taskSpec:
        params:
          - name: SERVICE
            type: string
            description: The service that was tested.
        workspaces:
          - name: output
            description: The workspace where the repository was cloned
        results:
          - name: status
            description: Status of the Data Router send operation (success/failure)
          - name: routing-id
            description: Data Router routing request ID for tracking
        steps:
          - name: send-results
            image: quay.io/dno/droute:latest
            imagePullPolicy: Always
            workingDir: $(workspaces.output.path)/source
            env:
              - name: DATAROUTER_USERNAME
                valueFrom:
                  secretKeyRef:
                    name: $(params.DATAROUTER_CREDENTIALS_NAME)
                    key: username
              - name: DATAROUTER_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: $(params.DATAROUTER_CREDENTIALS_NAME)
                    key: password
              - name: SERVICE
                value: "$(params.SERVICE)"
              - name: EVENT_TYPE
                valueFrom:
                  fieldRef:
                    fieldPath: metadata.labels['pac.test.appstudio.openshift.io/event-type']
              - name: PIPELINE_NAME
                value: "$(context.pipelineRun.name)"
            script: |
              #!/bin/bash
              set -euo pipefail
              
              ARTIFACT_DIR="${SERVICE}"/ct/target/surefire-reports
              METADATA_FILE="$(params.DATAROUTER-METADATA-PATH)"
              
              # Skip unsupported attributes by datarouter from the surefire reports:
              find "$ARTIFACT_DIR" -name "TEST-*.xml" -exec sed -i 's/ flakes="[0-9]*"//g' {} \;
              
              # Customize metadata for the current service
              sed -i "s/SERVICE_NAME/$SERVICE/g" datarouter.json
              sed -i "s/EVENT_TYPE_PLACEHOLDER/$EVENT_TYPE/g" datarouter.json
              sed -i "s/PIPELINE_NAME_PLACEHOLDER/$PIPELINE_NAME/g" datarouter.json
              
              echo "Using metadata from: $METADATA_FILE"
              echo "Metadata content:"
              cat "$METADATA_FILE" | jq . || cat "$METADATA_FILE"
              
              echo "Executing Data Router send"
              echo "  URL: $(params.datarouter-url)"
              echo "  Metadata: $METADATA_FILE"
              echo "  Results: $(params.results-pattern)"
              echo "  Attachments: $(params.attachments-dir)"
              echo "  Username: $DATAROUTER_USERNAME"
              echo "  Artifact directory: $ARTIFACT_DIR"
              
              # Retry configuration for intermittent 5xx errors
              MAX_RETRIES=3
              RETRY_DELAY=45
              
              # Function to execute droute command with retry
              execute_with_retry() {
                local attempt=1
                
                while [ $attempt -le $MAX_RETRIES ]; do
                  echo "=== Attempt $attempt of $MAX_RETRIES ==="
                  
                  # Temporarily disable exit on error to capture output
                  set +e
                  OUTPUT=$(/droute send --url=$(params.datarouter-url) --username=$DATAROUTER_USERNAME --password=$DATAROUTER_PASSWORD --metadata=$METADATA_FILE --results=$ARTIFACT_DIR/$(params.results-pattern) $(if [[ -n "$(params.attachments-dir)" ]]; then echo "--attachments=${ARTIFACT_DIR}/$(params.attachments-dir)"; fi) 2>&1)
                  EXIT_CODE=$?
                  set -e
                  
                  echo "Command completed with exit code: $EXIT_CODE"
                  echo "Output: $OUTPUT"
                  
                  # Check if successful
                  if [[ $EXIT_CODE -eq 0 ]]; then
                    return 0
                  fi
                  
                  # Check for retryable error patterns (only 5XX server errors)
                  if echo "$OUTPUT" | grep -qi -E "5[0-9][0-9] "; then
                    if [ $attempt -lt $MAX_RETRIES ]; then
                      echo "5XX server error detected. Retrying in $RETRY_DELAY seconds..."
                      sleep $RETRY_DELAY
                      attempt=$((attempt + 1))
                    else
                      echo "Maximum retries reached. Data Router send operation failed."
                      return $EXIT_CODE
                    fi
                  else
                    echo "Non-retryable error detected. Failing immediately."
                    return $EXIT_CODE
                  fi
                done
                
                return $EXIT_CODE
              }
              
              # Execute with retry logic
              execute_with_retry
              FINAL_EXIT_CODE=$?
              
              # Extract routing ID if available (from the last output)
              ROUTING_ID=$(echo "$OUTPUT" | grep -o "routing[_-]id[:\s]*[a-zA-Z0-9-]*" | head -1 | sed 's/.*[:\s]\+//' || echo "")
              
              # Set results
              if [[ $FINAL_EXIT_CODE -eq 0 ]]; then
                echo -n "success" > $(results.status.path)
                echo "Data Router send operation completed successfully"
              else
                echo -n "failure" > $(results.status.path)
                echo "Data Router send operation failed with exit code: $FINAL_EXIT_CODE"
              fi
              
              echo -n "$ROUTING_ID" > $(results.routing-id.path)
              
              exit $FINAL_EXIT_CODE
