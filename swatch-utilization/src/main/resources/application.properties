SERVER_PORT=${clowder.endpoints.swatch-utilization.port:8000}
LOGGING_LEVEL_COM_REDHAT_SWATCH=INFO
LOGGING_LEVEL_ROOT=INFO
ENABLE_SPLUNK_HEC=true
SPLUNK_HEC_URL=https://splunk-hec.redhat.com:8088/
SPLUNK_SOURCE=${quarkus.application.name}
SPLUNK_SOURCE_TYPE=quarkus_service
SPLUNK_HEC_BATCH_SIZE=1000
SPLUNK_HEC_BATCH_INTERVAL=10S
SPLUNK_HEC_RETRY_COUNT=0
SPLUNK_HEC_INCLUDE_EX=true
CORS_ORIGINS=/.+\\\\.redhat\\\\.com/
DISABLE_OTEL=true

# Customer over-usage detection threshold (percentage)
CUSTOMER_OVER_USAGE_DEFAULT_THRESHOLD_PERCENT=5.0

# dev-specific defaults; these can still be overridden by env var
%dev.SERVER_PORT=8018
%dev.QUARKUS_MANAGEMENT_PORT=9018
%dev.LOGGING_LEVEL_COM_REDHAT_SWATCH=DEBUG
%dev.SWATCH_SELF_PSK=placeholder
%dev.ENABLE_SPLUNK_HEC=false
%dev.SPLUNK_HEC_URL=https://splunk-hec.prod.utility-us-east-2.redhat.com:8088/
%dev.HOST_NAME=${USER}@${HOSTNAME}
%dev.SPLUNKMETA_namespace=local
%dev.SPLUNK_HEC_INCLUDE_EX=true
%dev.SPLUNK_DISABLE_CERTIFICATE_VALIDATION=true
%dev.CORS_ORIGINS=/.*/

# set the test profile properties to the same values as dev; these get activated for @QuarkusTest
%test.QUARKUS_MANAGEMENT_PORT=9018
%test.SWATCH_SELF_PSK=${%dev.SWATCH_SELF_PSK}
%test.ENABLE_SPLUNK_HEC=${%dev.ENABLE_SPLUNK_HEC}
%test.HOST_NAME=unit_tests

# ephemeral specifics:
%ephemeral.DISABLE_OTEL=true

# dev-specific config items that don't need to be overridden via env var
# do not use JSON logs in dev mode
quarkus.log.level=${LOGGING_LEVEL_ROOT}
quarkus.log.category."com.redhat.swatch".level=${LOGGING_LEVEL_COM_REDHAT_SWATCH}

quarkus.http.port=${SERVER_PORT}
# make quarkus choose a dynamic port for testing to avoid port collisions w/ simultaneous tests
quarkus.http.test-port=0
quarkus.http.cors.enabled=true
quarkus.http.cors.origins=${CORS_ORIGINS}
# Exposing the health checks and metrics on :9000.
quarkus.management.enabled=true
quarkus.management.root-path=/
quarkus.management.test-port=${QUARKUS_MANAGEMENT_PORT:9000}

# expose swagger-ui and openapi JSON/YAML on turnpike-friendly paths
quarkus.smallrye-openapi.path=/api/${quarkus.application.name}/internal/openapi
# By default, the openapi and swagger ui endpoints are exposed on the management port, so we need to disable it
# to expose it on the server port 8000:
quarkus.smallrye-openapi.management.enabled=false
quarkus.swagger-ui.always-include=true
quarkus.swagger-ui.path=/api/${quarkus.application.name}/internal/swagger-ui

# Unleash configuration
quarkus.unleash.devservices.enabled=${ENABLE_UNLEASH_DEV_SERVICES:false}
quarkus.unleash.url=${UNLEASH_URL:http://localhost:4242/api}
quarkus.unleash.token=${UNLEASH_API_TOKEN:default:development.unleash-insecure-api-token}
quarkus.unleash.name-prefix=swatch
## Disable the service in the test environment so that we can mock the service.
%test.quarkus.unleash.active=false
## Dev configuration
%dev.quarkus.unleash.fetch-toggles-interval=1
## Ephemeral configuration
%ephemeral.quarkus.unleash.fetch-toggles-interval=1

#clowder quarkus config takes care of setting the common kafka settings
kafka.bootstrap.servers=localhost:9092

# Kafka security configuration.  These properties must be present so that
# clowder-quarkus-config-source will populate them from the Clowder provided configuration JSON.
# If the properties are simply absent from this file, then clowder-quarkus-config-source will not
# set values for the property even if a value is present in the Clowder JSON.  The exception is the
# kafka.ssl.truststore.location which needs to evaluate to null for Kafka to use the system
# truststore.  Only specify kafka.ssl.truststore.location when you have an actual location to
# point to.  Don't set it to empty string.
#
# Additionally, Kafka has a bug, https://issues.apache.org/jira/browse/KAFKA-4090, where if a
# client attempts to connect to a TLS enabled port using PLAINTEXT, an OutOfMemoryException gets
# thrown instead of something more relevant to the actual issue.
kafka.sasl.jaas.config = ""
kafka.sasl.mechanism = PLAIN
kafka.security.protocol = PLAINTEXT
#kafka.ssl.truststore.location = ""
#kafka.ssl.truststore.type = PEM

# Consumer settings
mp.messaging.incoming.utilization-in.connector=smallrye-kafka
%test.mp.messaging.incoming.utilization-in.connector=smallrye-in-memory
mp.messaging.incoming.utilization-in.topic=platform.rhsm-subscriptions.utilization
mp.messaging.incoming.utilization-in.group.id=swatch-utilization-consumer
mp.messaging.incoming.utilization-in.value.deserializer=com.redhat.swatch.utilization.service.json.UtilizationSummaryDeserializer
mp.messaging.incoming.utilization-in.failure-strategy=ignore
mp.messaging.incoming.utilization-in.fail-on-deserialization-failure=false
mp.messaging.incoming.utilization-in.auto.offset.reset=latest
# The default commit strategy (throttle) batches offset commits and may
# delay committing offsets during low or no traffic periods.
mp.messaging.incoming.utilization-in.commit-strategy=latest
# Setting isolation.level=read_committed ensures that this consumer
# only processes messages from committed transactions.
mp.messaging.incoming.utilization-in.isolation.level=read_committed

# Producer settings
mp.messaging.outgoing.notifications-out.connector=smallrye-kafka
%test.mp.messaging.outgoing.notifications-out.connector=smallrye-in-memory
mp.messaging.outgoing.notifications-out.topic=platform.notifications.ingress
mp.messaging.outgoing.notifications-out.value.serializer=com.redhat.swatch.utilization.service.json.NotificationActionSerializer
# Workaround for https://github.com/smallrye/smallrye-reactive-messaging/issues/2465
# where 128 is the current default value for the buffer size
mp.messaging.outgoing.notifications-out.max-inflight-messages=128

quarkus.log.handler.splunk.enabled=${ENABLE_SPLUNK_HEC:false}
quarkus.log.handler.splunk.url=${SPLUNK_HEC_URL:https://splunk-hec.redhat.com:8088/}
quarkus.log.handler.splunk.disable-certificate-validation=${SPLUNK_DISABLE_CERTIFICATE_VALIDATION:false}
quarkus.log.handler.splunk.token=${SPLUNK_HEC_TOKEN:replaceme}
quarkus.log.handler.splunk.metadata-source=${SPLUNK_SOURCE:swatch-utilization}
quarkus.log.handler.splunk.metadata-source-type=${SPLUNK_SOURCE_TYPE:quarkus_service}
quarkus.log.handler.splunk.metadata-host=${HOST_NAME:${USER}@${HOSTNAME}}
quarkus.log.handler.splunk.batch-size-count=${SPLUNK_HEC_BATCH_SIZE:1000}
quarkus.log.handler.splunk.batch-interval=${SPLUNK_HEC_BATCH_INTERVAL:10S}
quarkus.log.handler.splunk.max-retries=${SPLUNK_HEC_RETRY_COUNT:0}
quarkus.log.handler.splunk.metadata-fields.namespace=${SPLUNKMETA_namespace:local}
quarkus.log.handler.splunk.format=%d %-5p [%c{3.}] (%t) %s%e%n
quarkus.log.handler.splunk.include-exception=${SPLUNK_HEC_INCLUDE_EX:false}
# Enable async handler with bounded queue to prevent OOM when HEC is slow or failing.
# See https://github.com/quarkiverse/quarkus-logging-splunk/issues/255
quarkus.log.handler.splunk.async.enabled=true
quarkus.log.handler.splunk.async.queue-length=512
quarkus.log.handler.splunk.async.overflow=discard

# otel config
quarkus.otel.sdk.disabled=${DISABLE_OTEL}

quarkus.otel.exporter.otlp.endpoint=${OTEL_EXPORTER_OTLP_ENDPOINT:http://splunk-otel-collector:4317}
# Metrics and logging are not yet supported - 30 Jul 2024
quarkus.otel.exporter.otlp.traces.protocol=${OTEL_EXPORTER_OTLP_PROTOCOL:grpc}

# Disable ALL dev services
quarkus.devservices.enabled=false
