SERVER_PORT: ${clowder.endpoints.swatch-metrics.port:8000}
LOGGING_LEVEL_COM_REDHAT_SWATCH: INFO
LOGGING_LEVEL_ROOT: INFO
ENABLE_SPLUNK_HEC: true
SPLUNK_HEC_URL: https://splunk-hec.redhat.com:8088/
SPLUNK_SOURCE: swatch-metrics
SPLUNK_SOURCE_TYPE: quarkus_service
SPLUNK_HEC_BATCH_SIZE: 1000
SPLUNK_HEC_BATCH_INTERVAL: 10S
SPLUNK_HEC_RETRY_COUNT: 3
SPLUNK_HEC_INCLUDE_EX: false
METRICS_IN_FAIL_ON_DESER_FAILURE: true
METERING_TASK_TOPIC: platform.rhsm-subscriptions.metering-tasks
SERVICE_INSTANCE_INGRESS_TOPIC: platform.rhsm-subscriptions.service-instance-ingress

# dev-specific defaults; these can still be overridden by env var
"%dev":
  LOGGING_LEVEL_COM_REDHAT_SWATCH: DEBUG
  SWATCH_SELF_PSK: placeholder
  ENABLE_SPLUNK_HEC: false
  SPLUNK_HEC_URL: https://splunk-hec.prod.utility-us-east-2.redhat.com:8088/
  SPLUNKMETA_host: ${USER}@${HOSTNAME}
  SPLUNKMETA_namespace: local
  SPLUNK_HEC_INCLUDE_EX: true
  quarkus:
    log:
      console:
        json: false

# set the test profile properties to the same values as dev; these get activated for @QuarkusTest
"%test":
  SWATCH_SELF_PSK: ${%dev.SWATCH_SELF_PSK}
  ENABLE_SPLUNK_HEC: ${%dev.ENABLE_SPLUNK_HEC}
  SPLUNKMETA_host: unit_tests
  quarkus:
    log:
      console:
        json: false

"%ephemeral":
  quarkus:
    otel:
      sdk:
        disabled: true
"%stage":
  quarkus:
    otel:
      sdk:
        disabled: false
"%prod":
  quarkus:
    otel:
      sdk:
        disabled: false

quarkus:
  http:
    port: ${SERVER_PORT}
    test-port: 0
  log:
    level: ${LOGGING_LEVEL_ROOT}
    category:
      "com.redhat.swatch":
        level: ${LOGGING_LEVEL_COM_REDHAT_SWATCH}
    handler:
      splunk:
        enabled: ${ENABLE_SPLUNK_HEC:false}
        url: ${SPLUNK_HEC_URL:https://splunk-hec.redhat.com:8088/}
        metadata-source: ${SPLUNK_SOURCE:swatch-metrics}
        max-retries: ${SPLUNK_HEC_RETRY_COUNT:0}
        metadata-source-type: ${SPLUNK_SOURCE_TYPE:quarkus_service}
        metadata-host: ${SPLUNKMETA_host:${USER}@${HOSTNAME}}
        metadata-fields:
          namespace: ${SPLUNKMETA_namespace:local}
        token: ${SPLUNK_HEC_TOKEN:replaceme}
        include-exception: ${SPLUNK_HEC_INCLUDE_EX:false}
        batch-size-count: ${SPLUNK_HEC_BATCH_SIZE:1000}
        format: '%d %-5p [%c{3.}] (%t) %s%e%n'
        batch-interval: ${SPLUNK_HEC_BATCH_INTERVAL:10S}
  swagger-ui:
    path: /api/${quarkus.application.name}/internal/swagger-ui
    always-include: true
  smallrye-openapi:
    path: /api/${quarkus.application.name}/internal/openapi
  otel:
    exporter:
      otlp:
        endpoint: http://splunk-otel-collector:4317
    sdk:
      disabled: true
  kafka:
    devservices:
      enabled: false
  reactive-messaging:
    kafka:
      serializer-generation:
        enabled: false
  rest-client:
    "com.redhat.swatch.clients.prometheus.api.resources.QueryApi":
      url: ${rhsm-subscriptions.metering.prometheus.client.url}
      scope: jakarta.enterprise.context.ApplicationScoped
    "com.redhat.swatch.clients.prometheus.api.resources.QueryRangeApi":
      url: ${rhsm-subscriptions.metering.prometheus.client.url}
      scope: jakarta.enterprise.context.ApplicationScoped

# Clowder quarkus config takes care of setting these, no need to try to do clowder.kafka.brokers[0]
# Common kafka settings
kafka:
  bootstrap:
    servers: localhost:9092
# Kafka security configuration.  These properties must be present so that
# clowder-quarkus-config-source will populate them from the Clowder provided configuration JSON.
# If the properties are simply absent from this file, then clowder-quarkus-config-source will not
# set values for the property even if a value is present in the Clowder JSON.
#
# Additionally, Kafka has a bug, https://issues.apache.org/jira/browse/KAFKA-4090, where if a
# client attempts to connect to a TLS enabled port using PLAINTEXT, an OutOfMemoryException gets
# thrown instead of something more relevant to the actual issue.
  sasl:
    jaas:
      # NOTE: empty string intentional, omitting the value is interpreted as null, and clowder
      # config source will not populate the config when null
      config: ''
    mechanism: PLAIN
  security:
    protocol: PLAINTEXT

# Consumer settings
mp:
  messaging:
    incoming:
      tasks-in:
        connector: smallrye-kafka
        # Note that clowder config will not resolve the topic from the clowder config file because
        # it does not properly resolve `${...}` properties.
        # This should be fixed by https://github.com/RedHatInsights/clowder-quarkus-config-source/pull/181
        topic: ${METERING_TASK_TOPIC}
        fail-on-deserialization-failure: ${METRICS_IN_FAIL_ON_DESER_FAILURE}
        auto:
          offset:
            reset: earliest
        value:
          deserializer: com.redhat.swatch.metrics.service.json.MetricsTaskDescriptorDeserializer
    outgoing:
      tasks-out:
        connector: smallrye-kafka
        # Note that clowder config will not resolve the topic from the clowder config file because
        # it does not properly resolve `${...}` properties.
        # This should be fixed by https://github.com/RedHatInsights/clowder-quarkus-config-source/pull/181
        topic: ${METERING_TASK_TOPIC}
        value:
          serializer: io.quarkus.kafka.client.serialization.ObjectMapperSerializer
      events-out:
        connector: smallrye-kafka
        # Note that clowder config will not resolve the topic from the clowder config file because
        # it does not properly resolve `${...}` properties.
        # This should be fixed by https://github.com/RedHatInsights/clowder-quarkus-config-source/pull/181
        topic: ${SERVICE_INSTANCE_INGRESS_TOPIC}
        value:
          serializer: io.quarkus.kafka.client.serialization.ObjectMapperSerializer

rhsm-subscriptions:
  prometheus-latency-duration: ${PROMETHEUS_LATENCY_DURATION:0h}
  enable-synchronous-operations: ${ENABLE_SYNCHRONOUS_OPERATIONS:false}
  metering:
    prometheus:
      client:
        token: ${PROM_AUTH_TOKEN:}
        url: ${PROM_URL:https://localhost/api/v1}
      metric:
        accountQueryTemplates:
          default: >-
            group(min_over_time(#{metric.prometheus.queryParams[metadataMetric]}{product='#{metric.prometheus.queryParams[product]}', external_organization != '', billing_model='marketplace'}[1h]))
            by (external_organization)
          addonSamples: >-
            group(min_over_time(#{metric.prometheus.queryParams[metadataMetric]}{resource_type="addon", resource_name='#{metric.prometheus.queryParams[resourceName]}', external_organization != '', billing_model='marketplace'}[1h]))
            by (external_organization)
          rhelemeter: >-
            group(min_over_time({product=~'#{metric.prometheus.queryParams[productLabelRegex]}', external_organization != '', billing_model='marketplace'}[1h]))
            by (external_organization)
        queryTemplates:
          default: >-
            max(#{metric.prometheus.queryParams[metric]}) by (#{metric.prometheus.queryParams[instanceKey]})
            * on(#{metric.prometheus.queryParams[instanceKey]}) group_right
            min_over_time(#{metric.prometheus.queryParams[metadataMetric]}{product="#{metric.prometheus.queryParams[product]}", external_organization="#{runtime[orgId]}", billing_model="marketplace", support=~"Premium|Standard|Self-Support|None"}[1h])
          addonSamples: >-
            max(#{metric.prometheus.queryParams[metric]}) by (#{metric.prometheus.queryParams[instanceKey]})
            * on(#{metric.prometheus.queryParams[instanceKey]}) group_right
            min_over_time(#{metric.prometheus.queryParams[metadataMetric]}{resource_type="addon",resource_name="#{metric.prometheus.queryParams[resourceName]}", external_organization="#{runtime[orgId]}", billing_model="marketplace", support=~"Premium|Standard|Self-Support|None"}[1h])
          rhelemeter: >-
            max(#{metric.prometheus.queryParams[metric]}) by (_id)
            * on(_id) group_right
            min_over_time({product=~"#{metric.prometheus.queryParams[productLabelRegex]}", external_organization="#{runtime[orgId]}", billing_model="marketplace", support=~"Premium|Standard|Self-Support|None"}[1h])
        maxAttempts: ${OPENSHIFT_MAX_ATTEMPTS:50}
        backOffMaxInterval: ${OPENSHIFT_BACK_OFF_MAX_INTERVAL:50000}
        backOffInitialInterval: ${OPENSHIFT_BACK_OFF_INITIAL_INTERVAL:1000}
        backOffMultiplier: ${OPENSHIFT_BACK_OFF_MULTIPLIER:1.5}
        eventSource: ${EVENT_SOURCE:prometheus}
        rangeInMinutes: ${OPENSHIFT_METERING_RANGE:60}
        jobMaxAttempts: ${METERING_JOB_MAX_ATTEMPTS:3}
        jobBackOffMaxInterval: ${METERING_JOB_BACK_OFF_MAX_INTERVAL:50000}
        jobBackOffInitialInterval: ${METERING_JOB_BACK_OFF_INITIAL_INTERVAL:1000}
