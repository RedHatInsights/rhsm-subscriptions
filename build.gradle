import groovy.json.JsonOutput

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath "org.openapitools:openapi-generator-gradle-plugin:5.4.0"
        classpath "org.jsonschema2pojo:jsonschema2pojo-gradle-plugin:1.1.1"
        classpath "de.undercouch:gradle-download-task:5.0.1"
    }
}

plugins {
    id "io.spring.dependency-management" version "1.0.11.RELEASE"
    id "com.diffplug.spotless" version "6.3.0"
    id "jacoco"
    id "org.sonarqube" version "3.3"
    id "org.springframework.boot" version "2.6.4"
    id "nebula.release" version "15.3.1"
    id "GitProperties"
    id 'com.adarshr.test-logger' version '3.0.0'
    // Only applied for the rhsm-subscriptions-kafka sub project; applied below.
    id "com.github.davidmc24.gradle.plugin.avro" version "1.3.0" apply false
}


ext {
    swagger_annotations_version = "1.6.5"
    swagger_ui_version = "4.5.2"
    resteasy_version = "3.6.3.Final"
    spring_boot_version = "2.6.4"
    jboss_jaxrs_api_version = "2.0.2.Final"
    resteasy_spring_boot_starter_version = "3.9.1.Final"
    kafka_avro_serializer_version = "7.0.1"
    avro_version = "1.11.0"
    webjars_locator_version = "0.45"
    hawtio_springboot_version = "2.14.5"
    guava_version = "31.1-jre"
    janino_version = "3.1.6"
    splunk_library_javalogging_version = "1.11.4"

    generatedMetamodels = "build/generated/sources/annotationProcessor/java/main/org/candlepin/subscriptions"
}

allprojects {
    apply plugin: "java"
    apply plugin: "io.spring.dependency-management"

    apply plugin: "com.diffplug.spotless"
    spotless {
        java {
            targetExclude '**/build/**' // exclude generated code
            enforceCheck false //allows build task to be successful, even if there is a code style violation
            googleJavaFormat()
            licenseHeaderFile "${rootDir}/config/codestyle/HEADER.txt" //lets you specify code that you don't want to violate rules or be reformatted
            toggleOffOn()
        }
    }
    // Define all versions here so that all projects will use the same versions.
    dependencyManagement {
        imports {
            // See https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-dependencies to
            // get listings of the contents of this BOM
            mavenBom "org.springframework.boot:spring-boot-dependencies:$spring_boot_version"
        }
        dependencies{
            dependency "org.jboss.spec.javax.ws.rs:jboss-jaxrs-api_2.1_spec:$jboss_jaxrs_api_version"
            dependency "io.swagger:swagger-annotations:$swagger_annotations_version"
            dependency "org.webjars:swagger-ui:$swagger_ui_version"
            dependency "org.webjars:webjars-locator:$webjars_locator_version"
            dependency "org.jboss.resteasy:resteasy-spring-boot-starter:$resteasy_spring_boot_starter_version"
            dependencySet(group: "org.jboss.resteasy", version: "$resteasy_version") {
                entry "resteasy-client"
                entry "resteasy-multipart-provider"
                entry "resteasy-validator-provider-11"
                entry "resteasy-jackson2-provider"
            }
            dependency "io.confluent:kafka-avro-serializer:$kafka_avro_serializer_version"
            dependency "org.apache.avro:avro:$avro_version"
            dependency "io.hawt:hawtio-springboot:$hawtio_springboot_version"
            dependency "com.google.guava:guava:$guava_version"
            dependency "com.splunk.logging:splunk-library-javalogging:$splunk_library_javalogging_version"
            dependency "org.codehaus.janino:janino:$janino_version"
        }
    }

    sourceCompatibility = "11"
    targetCompatibility = "11"

    tasks.withType(JavaCompile) {
        options.compilerArgs << '-parameters'
    }

    repositories {
        mavenCentral()
        maven { url "https://packages.confluent.io/maven/" }
        maven{
            url 'https://splunk.jfrog.io/splunk/ext-releases-local'
        }
    }

    test {
        useJUnitPlatform()
    }

    jacocoTestReport {
        reports {
            xml.enabled true
        }
    }

    group = "org.candlepin"

    dependencies {
        implementation 'javax.annotation:javax.annotation-api:1.3.2'
        compileOnly "org.projectlombok:lombok"
        annotationProcessor "org.projectlombok:lombok"
        testCompileOnly "org.projectlombok:lombok"
        testAnnotationProcessor "org.projectlombok:lombok"
        annotationProcessor('org.hibernate:hibernate-jpamodelgen')
        annotationProcessor "org.springframework.boot:spring-boot-configuration-processor"

        testImplementation "org.springframework.boot:spring-boot-starter-test"
        testImplementation "org.springframework:spring-test"

        // We use JUnit 5 which the spring-boot-starter-test doesn't provide
        testImplementation "org.junit.jupiter:junit-jupiter-api"
        testImplementation "org.junit.jupiter:junit-jupiter-params"
        testImplementation "org.mockito:mockito-core"
        testImplementation "org.mockito:mockito-junit-jupiter"
        testImplementation "org.hamcrest:hamcrest"

        testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine"
        testRuntimeOnly "ch.qos.logback:logback-classic"
    }

    sourceSets {
      main.java.srcDirs+=generatedMetamodels
    }

  compileJava {
      options.annotationProcessorGeneratedSourcesDirectory = file(generatedMetamodels)
  }
}

// Disable the default jar; otherwise we end up with two different jars in the final image
// See https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives
jar {
    enabled = false
}

bootJar {
    mainClass = "org.candlepin.subscriptions.BootApplication"
}

springBoot {
    buildInfo {
        properties {
            // Leave time empty: The default value is the instant at which the project is built. A
            // side-effect is the task will never be up-to-date. As a result, builds will take longer.  See
            // https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/gradle-plugin/reference/html/#integrating-with-actuator
            time = null
            additional = [
                    'gitDescription': "${project.git.description ?: ''}",
                    'gitHash': "${project.git.hash ?: ''}",
            ]
        }
    }
}

dependencies {
    implementation project(':swatch-core')
    // Generates configuration metadata that IntelliJ can use
    annotationProcessor('org.hibernate:hibernate-jpamodelgen')
    // For the LiveReload feature of spring boot as long as IntelliJ is set to build/make automatically on
    // code changes
    implementation('org.springframework.boot:spring-boot-devtools')

    implementation project(":api")
    implementation project(":clients:cloudigrade-client")
    implementation project(":clients:insights-inventory-client")
    implementation project(":clients:rh-marketplace-client")
    implementation project(":clients:product-client")
    implementation project(":clients:prometheus-client")
    implementation project(":clients:rbac-client")
    implementation project(":clients:rhsm-client")
    implementation project(":clients:subscription-client")
    implementation project(":clients:user-client")
    implementation project(":kafka-schema")

    // This starter pulls in Spring Boot versions that we don't want.  The actual classes that we need are
    // baked into the starter artifact itself which is peculiar but sometimes that's how the cookie crumbles.
    implementation("org.jboss.resteasy:resteasy-spring-boot-starter") {
        exclude group: "org.springframework.boot"
    }
    implementation("io.confluent:kafka-avro-serializer") {
        exclude group: "org.apache.kafka"
        // A transitive dependency, org.apache.zookeeper:zookeeper, includes log4j as well as slf4j.  We use
        // logback and SLF4J issues a warning if more than one logging implementation is on the classpath.
        // Frowny face to Zookeeper for adding a logging implementation to a library jar.
        exclude group: "org.slf4j", module: "slf4j-log4j12"
    }

    implementation "org.springframework.boot:spring-boot-starter-actuator"
    implementation "org.springframework.boot:spring-boot-starter-aop"
    implementation "org.springframework.boot:spring-boot-starter-data-jpa"
    implementation "org.springframework.boot:spring-boot-starter-security"
    implementation "org.springframework.boot:spring-boot-starter-web"
    implementation "org.springframework.retry:spring-retry"
    implementation "org.springframework:spring-context-support"
    implementation "org.springframework.kafka:spring-kafka"
    // the following dep is necessary to avoid jackson kotlin warnings
    implementation "com.fasterxml.jackson.module:jackson-module-kotlin"

    implementation "io.micrometer:micrometer-registry-prometheus"
    implementation "org.liquibase:liquibase-core"
    implementation "org.webjars:swagger-ui"
    implementation "org.webjars:webjars-locator"
    implementation "org.yaml:snakeyaml"
    implementation "org.postgresql:postgresql"
    implementation "io.hawt:hawtio-springboot"
    implementation "org.hibernate.validator:hibernate-validator"

    testImplementation "org.springframework.security:spring-security-test"
    testImplementation "org.springframework.kafka:spring-kafka-test"
    testImplementation project(':swatch-core-test')

    runtimeOnly("org.jboss.resteasy:resteasy-validator-provider-11") {
        exclude group: 'org.hibernate' // exclude older hibernate validator
    }

    runtimeOnly "org.hsqldb:hsqldb"
    runtimeOnly "org.jolokia:jolokia-core"
}

allprojects {
    // Add a custom task to output dependency info in a machine parseable format. Used to generate dependency
    // reports for Product Security.
    // adapted from https://stackoverflow.com/a/34641632
    // easiest to use via `./gradlew -q dependencyJson`
    tasks.register('dependencyJson') {
        doLast {
            def collectDeps = { ResolvedDependency dependency ->
                def collectedDeps = []
                // depth first traversal
                def dependencyStack = [dependency]
                while (!dependencyStack.isEmpty()) {
                    ResolvedDependency current = dependencyStack.pop()
                    collectedDeps.add(current)
                    current.children.forEach { dependencyStack.push(it) }
                }
                return collectedDeps
            }
            Set allDeps = []
            def nonTestProjects = allprojects.grep { project -> !project.name.endsWith("-test") }
            for (Project project : nonTestProjects) {
                // see https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management
                // "default" is all artifacts required at runtime
                for (ResolvedDependency topLevelDependency : project.configurations.default.resolvedConfiguration.firstLevelModuleDependencies) {
                    def collectedDeps = collectDeps(topLevelDependency)
                    for (ResolvedDependency dependency : collectedDeps) {
                        // skip deps that appear to be from this project
                        if (dependency.moduleGroup != project.group || dependency.moduleVersion != project.version) {
                            allDeps.add([
                                    group  : dependency.moduleGroup,
                                    name   : dependency.moduleName,
                                    version: dependency.moduleVersion,
                            ])
                        }
                    }

                }
            }
            println JsonOutput.toJson(allDeps.sort { "${it.group}:${it.name}:${it.version}" })
        }
    }
}

sourceSets {
    main.java.srcDir generatedMetamodels
}

compileJava {
    options.annotationProcessorGeneratedSourcesDirectory = file(generatedMetamodels)
}

compileJava.dependsOn(processResources)
project.tasks["sonarqube"].dependsOn "test"
project.tasks["sonarqube"].dependsOn "jacocoTestReport"

project(":api") {
    apply plugin: "org.openapi.generator"

    ext {
        api_spec_path = "${projectDir}/rhsm-subscriptions-api-spec.yaml"
        config_file = "${projectDir}/rhsm-subscriptions-api-config.json"
    }

    openApiGenerate {
      generatorName = "jaxrs-spec"
      inputSpec = api_spec_path
      configFile = config_file
      outputDir = "$buildDir/generated"
      configOptions = [
          interfaceOnly: "true",
          generatePom: "false",
          dateLibrary: "java8",
      ]
    }

    openApiValidate {
        inputSpec = api_spec_path
    }

    task generateApiDocs(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "html"
        inputSpec = api_spec_path
        outputDir = "$buildDir/docs"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    task generateOpenApiJson(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "openapi"
        inputSpec = api_spec_path
        outputDir = "$buildDir/generated/openapijson"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    processResources {
        from "$buildDir/generated/openapijson/openapi.json"
        from api_spec_path
        rename { String fileName ->
            api_spec_path.endsWith(fileName) ? 'openapi.yaml' : fileName  // rename yaml to openapi.yaml
        }
    }

    dependencies {
        implementation "com.fasterxml.jackson.core:jackson-annotations"
        implementation "javax.validation:validation-api"
        implementation "org.jboss.spec.javax.ws.rs:jboss-jaxrs-api_2.1_spec"
        implementation "io.swagger:swagger-annotations"
        implementation "com.google.code.findbugs:jsr305:3.0.2"
        implementation "org.openapitools:jackson-databind-nullable:0.2.2"
    }

    sourceSets.main.java.srcDirs = ["${buildDir}/generated/src/gen/java"]
    compileJava.dependsOn tasks.openApiGenerate
    processResources.dependsOn tasks.generateOpenApiJson
}

project(":kafka-schema") {
    apply plugin: "com.github.davidmc24.gradle.plugin.avro"

    dependencies {
        implementation "org.apache.avro:avro"
    }

    task generateAvro(type: com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask) {
        // sub dir needed so that the plugin does not traverse into the build dir (if it exists).
        source("${projectDir}/avro")
        outputDir = file("${buildDir}/generated/avro/src/main/java")
    }

    sourceSets.main.java.srcDirs += "${buildDir}/generated/avro/src/main/java"
    compileJava.source(generateAvro.outputs)
    compileJava.dependsOn tasks.generateAvro
}
